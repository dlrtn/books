# 스트림과 컬렉션

---

- 자바의 `컬렉션`과 `스트림` 모두 연속된 요소 형식의 값을 저장하는 `자료구조의 인터페이스`를 제공한다.
- 여기서 `연속된`이라는 표현은 순서와 상관없이 아무 값에나 접근하는 것이 아닌, `순차적으로 값에 접근`한다는 것을 의미한다.

- 이제 `컬렉션`과 `스트림`의 차이를 알아보자.
    - 시각적인 차이
        - DVD에 어떤 영화가 저장되어 있다고 할때, DVD에 전체 자료구조가 저장되어 있으므로 DVD도 컬렉션이다.
        - 이번에는 DVD가 아니라 인터넷 스트리밍으로 같은 비디오를 시청한다고 하자. 여기서 스트리밍, 즉 스트림이 등장했다.
        - 스트리밍으로 재생할 때는 몇 프레임을 미리 내려받는다. 그러면 스트림의 다른 대부분의 값을 처리하지 않은 상태에서 내려받은 프레임부터 재생할 수 있다.
    - 데이터를 **언제** 계산하느냐가 `컬렉션`과 `스트림`의 **가장 큰 차이**다.
        - `컬렉션`은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조다. 즉 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다.
        - `스트림`은 이론적으로 **요청할 때만 요소를 계산**하는 고정된 자료구조다. 이러한 스트림의 특성은 프로그래밍에 큰 도움을 준다.
    - 여기서 **사용자가 요청하는 값만 스트림에서 추출**한다는 것이 핵심이다. 물론 사용자 입장에서는 이런 변화는 알 수 없다.
    - 결과적으로 `스트림`은 `생산자`와 `소비자` 관계를 형성하는데 스트림은 게으르게 만들어지는 컬렉션과 같다.
        - 즉, 사용자(소비자)가 데이터를 요청할 때만 값을 계산한다.

      ⇒ 경영학에서는 이를 `요청 중심 제조`라고 부른다. 주문이 들어오면 제품을 생산한다.

    - 반면 컬렉션은 적극적으로 생성된다.

      ⇒ 경영학에서는 이를 `생산자 중심`이라고 부른다. 주문이 들어오든 말든 일단 만들어놓고 판다.


### 1. 딱 한 번만 탐색할 수 있다.

---

- 반복자와 마찬가지로 스트림도 한 번만 탐색할 수 있다. 즉 탐색된 스트림의 요소는 소비되어진다.
- 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 다시 만들어야 한다.

  ⇒ 만일 데이터 소스가 `I/O 채널`이라면 소스를 반복 사용할 수 없으므로 새로운 스트림을 만들 수 없다.

    ```java
    List<String> title = Arrays.asList("Java8", "In", "Action");
    Stream<String> s = title.stream();
    s.forEach(System.out::println)); // title의 각 단어를 출력
    s.forEach(System.out::println)); // java.lang.illegalStateException: 스트림이 이미 소비되었거나 닫힘
    ```

    - 스트림은 단 한 번만 소비할 수 있다는 점을 명심하자.

### 2. 외부 반복과 내부 반복

---

- 컬렉션과 스트림의 또 다른 차이점은 데이터 반복 처리 방법이다.
- 컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복시켜야 한다.
- 이를 **외부 반복**이라고 한다. 반면 스트림 라이브러리는 **내부 반복**을 사용한다. 함수에 어떤 작업을 수행할지만 지정하면 모든 것이 알아서 처리된다.

```java
List<String> names = new ArrayList<>();
for(Dish dish: menu) {  // 메뉴 리스트를 명시적으로 순차 반복한다.
	name.add(dish.getName()); // 이름을 추출해서 리스트에 추가한다.
}
```

- `for-each` 구문은 반복자를 사용하는 불편함을 어느정도 해소해준다. `for-each`를 이용하면 `Iterator` 객체를 이용하는 것보다 더 쉽게 컬렉션을 반복시킬 수 있다.
- 다음은 위 `for-each`문의 내부 구현이다.

    ```java
    List<String> names = new ArrayList<>();
    Iterator<String> iterator = menu.iterator();
    while(iterator.hasNext()) {
    	Dish dish = iterator.next();
    	name.add(dish.getName()); 
    }
    ```

- 다음은 스트림의 내부 반복을 사용한 방법이다.

    ```java
    List<String> names = menu.stream()
    	.map(Dish::getName)
    	.collect(toList());
    ```

- 내부 반복은 외부 반복과 어떤 점이 다르며 어떤 이득을 줄까?
    - `내부 반복`을 사용하면 작업을 투명하게 병렬적으로 처리하거나 최적화된 다양한 순서로 처리가 가능하다.
    - `외부 반복`에서는 병렬성을 **스스로 관리**해야 한다.
    - `외부 반복`을 사용하면 `How` 중심의 코드를 짜게 되지만, `내부 반복`을 이용하면 `What` 중심의 코드를 짤 수 있다.

  ⇒ 더 직관적이며 병렬성을 쉽게 사용할 수 있게 제공해준다.