- 그래서 어디서 람다를 사용할 수 있을까?

  → `함수형 인터페이스`라는 문맥에서 `람다 표현식`을 사용할 수 있다.

### 1. 함수형 인터페이스

---

- 앞서 우리는 `Predicate<T>` 인터페이스에 동적 파라미터를 전달함으로써 전략 패턴을 사용할 수 있었다.

- 그 `Predicate<T>`가 `함수형 인터페이스`다. `Predicate<T>`는 오직 하나의 추상 메서드만 지정하기 때문이다.

 ```java
public interface Predicate<T {
  boolean test (T t);
}
 ```

- 간단하게 말해서 함수형 인터페이스는 하나의 추상 메서드를 지정하는 인터페이스다.

- 자바 API의 `함수형 인터페이스`로는 `Comparator`, `Runnable` 등이 있다.

- `함수형 인터페이스`로 뭘 할 수 있을까?

- `람다 표현식`으로 함수형 인터페이스의 추상 메서드의 구현을 전달할 수 있으므로 전체 표현식을 `함수형 인터페이스의 인스턴스`로 취급할 수 있다.

### 2. 함수 디스크립터

---

- `함수형 인터페이스`의 추상 메서드 시그니처는 람다 표현식의 시그니처다.

- 람다 표현식의 시그니처를 서술하는 메서드는 `함수 디스크립터`라고 부른다.

    - 예를 들어 `Runnable` 인터페이스의 유일한 추상 메서드 `run`은 인수와 반환 값이 없으므로 `Runnable` 인터페이스의 람다 표현식 시그니처는 인수와 반환값이 없는 시그니처다.

- 그렇다면 이런 `람다 표현식`의 형식을 인수로 받는 함수는 어떻게 검사할까?, 이는 3.5절에서 컴파일러가 `람다 표현식의 유효성`을 어떻게 확인하는지 설명한다.

- `람다 표현식`은 `변수`, `함수형 인터페이스를 인수로 받는 메서드`에 전달할 수 있으며 함수형 인터페이스의 추상 메서드와 같은 시그니처를 갖는다는 사실을 기억하는 것으로 충분하다.

  ⇒ 그렇다면 왜 `함수형 인터페이스`를 인수로 받는 메서드에만 람다 표현식을 사용할 수 있을까?

    - 언어설계자들은 함수 형식을 추가하는 방법도 고려했으나 언어를 더 복잡하게 만드는 방법이었고 대부분의 자바 프로그래머가 하나의 추상 메서드를 갖는 인터페이스에 익숙하다는 점을 토대로 결정하였다.

---