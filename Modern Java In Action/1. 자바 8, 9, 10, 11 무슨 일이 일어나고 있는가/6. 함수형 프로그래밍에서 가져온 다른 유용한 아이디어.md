- 지금까지 자바에 포함된 함수형 프로그래밍의 핵심적인 두 아이디어(`메서드와 람다, 함수를 일급 객체`, `가변 공유 상태가 없는 병렬 실행`)를 살펴봤다.
- 그 외의 요소들을 한 번 알아보자.

### Optional<T>

---

- 자바 8에서는 `NullPointerException`을 피할 수 있도록 도와주는 `Optional<T>` 클래스를 제공한다.
- `Optional<T>`는 값을 갖거나 갖지 않을 수 있는 컨테이너 객체다. 값이 없는 상황을 어떻게 처리할지 명시적으로 구현하는 메서드를 포함하고 있다.
- 따라서 `Optional<T>`를 사용하면 `NullPointerException`을 피할 수 있다. 즉 형식 시스템을 이용해서 어떤 변수에 값이 없을 때 어떻게 처리할 지 명시할 수 있다는 것이다.

### 패턴 매칭

---

- 패턴 매칭은 수학에서 다음 예제처럼 사용한다.

```java
f(0) = 1
f(n) = n * f(n-1) 그렇지 않으면
```

- 자바에서는 `if-then-else`나 `switch` 문을 사용했을 것이다. 그러나 다른 언어에서는 패턴 매칭으로 더 정확한 비교를 구현할 수 있었다.
- 물론 자바에서도 다형성, 메서드 오버라이딩을 이용해서 `if-then-else`를 대신하는 비교문을 만들 수 있다.
- 19장에서 패턴 매칭을 자세하게 설명한다. 하지만 자바 8은 패턴 매칭을 완벽하게 지원하지 않는다. 그런 이유로 스칼라로 패턴 매칭을 사용하는 방법을 살펴본다. 다음은 그 예시다.

    ```scala
    def simplifyExpression(expr: Expr): Expr = expr match {
    	case BinOp("+", e, Number(0)) => e
    	case BinOp("-", e, Number(0)) => e
    	case BinOp("*", e, Number(1)) => e
    	case BinOp("/", e, Number(1)) => e
    	case _ => expr
    }
    ```

- 스칼라의 `expr match`는 자바의 `swith(expr)`와 유사하게 동작한다.
- 지금은 패턴 매칭이 `switch`를 확장해 데이터 형식 분류와 분석을 한 번에 수행할 수 있다는 정도만 알고 넘어가자.
---